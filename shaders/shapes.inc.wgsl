//-----------------------------------------------------------------------------
// Copyright (c) 2024 Electronic Arts.  All rights reserved.
//-----------------------------------------------------------------------------

//!include matrix.inc

// Code-generated by BufferFactory
//!insert SimShape

struct CollideResult
{
    collides: bool,
    penetration: f32,
    normal: vec2f,
    pointOnCollider: vec2f,
};

fn collide(shape: SimShape, pos: vec2f) -> CollideResult
{
    if(shape.shapeType == ShapeTypeCircle)
    {
        let offset = shape.position - pos;
        let offsetLen = length(offset);
        let normal = offset * select(1.0/offsetLen, 0, offsetLen == 0);
        return CollideResult(
            offsetLen <= shape.radius,
            -(offsetLen - shape.radius),
            normal,
            shape.position+normal*shape.radius,
        );
    }
    else if(shape.shapeType == ShapeTypeBox)
    {
        let offset = pos - shape.position;
        let R = rot(shape.rotation / 180.0 * 3.14159);
        let rotOffset = R * offset;
        let sx = sign(rotOffset.x);
        let sy = sign(rotOffset.y);
        let penetration = -(abs(rotOffset) - shape.halfSize);
        let normal = transpose(R)*select(vec2f(sx,0), vec2f(0,sy), penetration.y < penetration.x);
        let minPen = min(penetration.x, penetration.y);

        let pointOnBox = shape.position + transpose(R)*clamp(rotOffset, -shape.halfSize, shape.halfSize);

        return CollideResult(
            minPen > 0,
            minPen,
            -normal,
            pointOnBox
        );
    }
    else
    {
        return CollideResult(false, 0.0, vec2f(0,0), vec2f(0,0));
    }
}
